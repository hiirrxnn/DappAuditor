{
  "patterns": [
    {
      "id": "enhanced_reentrancy",
      "name": "Reentrancy Vulnerability (Dataset Enhanced)",
      "severity": "critical",
      "pattern": "(\\.call\\s*\\{[^}]*\\}\\s*\\([^)]*\\)|msg\\.sender\\.call|address\\([^)]*\\)\\.call)(?!.*require\\s*\\(.*success)",
      "description": "External calls vulnerable to reentrancy attacks",
      "recommendation": "Use ReentrancyGuard, checks-effects-interactions pattern, or pull payment",
      "cwe": "CWE-841",
      "examples": [
        "function withdraw() public {\n    uint256 amount = balances[msg.sender];\n    require(amount > 0, \"No funds\");\n    \n    // Vulnerable: external call before state change\n    (bool success,) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n    \n    balances[msg.sender] = 0; // State change after external call\n}",
        "function emergencyWithdraw() external {\n    uint256 balance = getUserBalance(msg.sender);\n    // Vulnerable: external call in modifier/helper\n    IToken(token).transfer(msg.sender, balance);\n    userBalances[msg.sender] = 0;\n}"
      ],
      "prevalence": 0.2
    },
    {
      "id": "enhanced_timestamp",
      "name": "Timestamp Dependence (Dataset Enhanced)",
      "severity": "medium",
      "pattern": "(block\\.timestamp|now(?!\\w)).*(?:require|if|>|<|>=|<=)",
      "description": "Logic dependent on block timestamp manipulation",
      "recommendation": "Use block numbers or external oracles for time-dependent logic",
      "cwe": "CWE-829",
      "examples": [
        "function withdraw() public {\n    require(block.timestamp > deadline, \"Too early\");\n    // Vulnerable: miners can manipulate timestamp\n    payable(msg.sender).transfer(balance);\n}",
        "uint256 randomNumber = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 100;"
      ],
      "prevalence": 0.2
    },
    {
      "id": "enhanced_access_control",
      "name": "Access Control Issues (Dataset Enhanced)",
      "severity": "high",
      "pattern": "function\\s+\\w+\\s*\\([^)]*\\)\\s*(?:public|external)(?![^{]*\\b(?:onlyOwner|require\\s*\\(.*msg\\.sender))",
      "description": "Functions lacking proper access control",
      "recommendation": "Implement proper access control modifiers and checks",
      "cwe": "CWE-284",
      "examples": [
        "function withdraw() public {\n    // Missing access control!\n    payable(msg.sender).transfer(address(this).balance);\n}",
        "modifier onlyOwner() {\n    require(tx.origin == owner, \"Not owner\");\n    _; // Should use msg.sender instead of tx.origin\n}"
      ],
      "prevalence": 0.2
    },
    {
      "id": "enhanced_overflow",
      "name": "Integer Overflow/Underflow (Dataset Enhanced)",
      "severity": "high",
      "pattern": "(?:uint\\d*|int\\d*)\\s+\\w+\\s*[+\\-*\\/]=?\\s*\\w+(?!.*(?:SafeMath|unchecked))",
      "description": "Arithmetic operations without overflow protection",
      "recommendation": "Use SafeMath library or Solidity 0.8+ built-in checks",
      "cwe": "CWE-190",
      "examples": [
        "function transfer(address to, uint256 amount) public {\n    balances[msg.sender] -= amount; // Potential underflow\n    balances[to] += amount; // Potential overflow\n}",
        "uint256 total = price * quantity; // Potential overflow\nrequire(msg.value >= total, \"Insufficient payment\");"
      ],
      "prevalence": 0.2
    },
    {
      "id": "enhanced_unchecked_call",
      "name": "Unchecked External Calls (Dataset Enhanced)",
      "severity": "high",
      "pattern": "(?:\\.call\\s*\\([^)]*\\)|payable\\([^)]*\\)\\.(?:send|transfer))\\s*;(?!.*(?:require\\s*\\(|success))",
      "description": "External calls without return value verification",
      "recommendation": "Always check return values of external calls",
      "cwe": "CWE-252",
      "examples": [
        "function sendPayment(address to, uint256 amount) public {\n    to.call{value: amount}(\"\"); // Return value not checked\n}",
        "payable(winner).send(prize); // send() can fail silently"
      ],
      "prevalence": 0.2
    }
  ],
  "examples": [
    {
      "id": "reentrancy_synthetic_0",
      "type": "reentrancy",
      "severity": "critical",
      "code": "function withdraw() public {\n    uint256 amount = balances[msg.sender];\n    require(amount > 0, \"No funds\");\n    \n    // Vulnerable: external call before state change\n    (bool success,) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n    \n    balances[msg.sender] = 0; // State change after external call\n}",
      "description": "Classic reentrancy vulnerability in withdrawal function",
      "source": "synthetic"
    },
    {
      "id": "reentrancy_synthetic_1",
      "type": "reentrancy",
      "severity": "critical",
      "code": "function emergencyWithdraw() external {\n    uint256 balance = getUserBalance(msg.sender);\n    // Vulnerable: external call in modifier/helper\n    IToken(token).transfer(msg.sender, balance);\n    userBalances[msg.sender] = 0;\n}",
      "description": "Reentrancy through external token transfer",
      "source": "synthetic"
    },
    {
      "id": "timestamp_0",
      "type": "timestamp_dependence",
      "severity": "medium",
      "code": "function withdraw() public {\n    require(block.timestamp > deadline, \"Too early\");\n    // Vulnerable: miners can manipulate timestamp\n    payable(msg.sender).transfer(balance);\n}",
      "description": "Timestamp dependence in withdrawal logic",
      "source": "synthetic"
    },
    {
      "id": "timestamp_1",
      "type": "timestamp_dependence",
      "severity": "medium",
      "code": "uint256 randomNumber = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 100;",
      "description": "Using timestamp for randomness generation",
      "source": "synthetic"
    },
    {
      "id": "access_control_0",
      "type": "access_control",
      "severity": "critical",
      "code": "function withdraw() public {\n    // Missing access control!\n    payable(msg.sender).transfer(address(this).balance);\n}",
      "description": "Missing access control on critical function",
      "source": "synthetic"
    },
    {
      "id": "access_control_1",
      "type": "access_control",
      "severity": "high",
      "code": "modifier onlyOwner() {\n    require(tx.origin == owner, \"Not owner\");\n    _; // Should use msg.sender instead of tx.origin\n}",
      "description": "Using tx.origin instead of msg.sender",
      "source": "synthetic"
    },
    {
      "id": "overflow_0",
      "type": "integer_overflow",
      "severity": "high",
      "code": "function transfer(address to, uint256 amount) public {\n    balances[msg.sender] -= amount; // Potential underflow\n    balances[to] += amount; // Potential overflow\n}",
      "description": "Integer overflow/underflow in balance operations",
      "source": "synthetic"
    },
    {
      "id": "overflow_1",
      "type": "integer_overflow",
      "severity": "high",
      "code": "uint256 total = price * quantity; // Potential overflow\nrequire(msg.value >= total, \"Insufficient payment\");",
      "description": "Multiplication overflow in payment calculation",
      "source": "synthetic"
    },
    {
      "id": "unchecked_call_0",
      "type": "unchecked_call",
      "severity": "high",
      "code": "function sendPayment(address to, uint256 amount) public {\n    to.call{value: amount}(\"\"); // Return value not checked\n}",
      "description": "Unchecked external call return value",
      "source": "synthetic"
    },
    {
      "id": "unchecked_call_1",
      "type": "unchecked_call",
      "severity": "high",
      "code": "payable(winner).send(prize); // send() can fail silently",
      "description": "Using send() without checking return value",
      "source": "synthetic"
    }
  ],
  "statistics": {
    "totalContracts": 10,
    "vulnerabilityDistribution": {
      "reentrancy": 2,
      "timestamp_dependence": 2,
      "access_control": 2,
      "integer_overflow": 2,
      "unchecked_call": 2
    },
    "processedDate": "2025-07-22T08:24:29.414Z"
  }
}